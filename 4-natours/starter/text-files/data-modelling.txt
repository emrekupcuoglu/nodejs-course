Check lecture 148 for more information
Data modelling is the process of taking unstructured data generated by a
real world scenario and then structure it into a logical data model in a database
according to a set of criteria. 
For example let's say we want to design an online shop data model, there will be
initially ton of unstructured data that we know we need, stuff like products, categories,
customers, orders, shopping carts, suppliers, and etc.
Out goal with data modeling is to structure this data into a logical way. 
Reflecting the real world relationships that exist between these data sets.
Many backend developers say that the data modeling is where we have to think the most
that is is the most demanding part of building an entire application,
because it is not always straight forward and sometimes there are no right answers.

We are going to go through 4 steps to try and find the best way
1. Identify different types of relationships between data
2. Understand the difference between referencing/normalization and embedding/de-normalization
3. This is the most important step and we will use a framework to decide whether we should embed documents
or reference other documents based on a couple of different factors
4. Types of referencing

1. Types of Relationships Between Data
There are three big types of relationships between data
One to one (1:1)
One to many (1:many)
many to many (many:many)

ONE TO ONE RELATIONSHIPS (1:1)
We will use a movie application as an example
A 1:1 relationships between data is basically when one field can only have one value
In our movie application example one movie will only ever have one name this is a simple example of  a 1:1 relationship.
But these 1:1 relationships are not that important in terms of data modeling.

ONE TO MANY RELATIONSHIPS (1:MANY)

Most important relationships are the 1:many relationships. And they are so important in mongoDB we actually distinguish
between three types of 1:many relationships.
1:FEW, 1:MANY, 1:TON
The difference is based on the relative amount of the many.
Example to a 1:FEW is a movie can win many awards but they are few relatively
In general 1:MANY relationship means that one document can relate to many other documents 
In a 1:MANY relationship one document can relate to hundreds or thousands of other documents.
For example a movie can have thousands of reviews.
For 1:TON imagine we wanted to implement a logging functionality in our app to know what is going on on our server.
These logs can easily grow to millions of documents
The difference between 1:MANY and 1:TON is fuzzy but think if something can grow almost to infinity then it is definitely 1:TON
BTW in relational databases there is just 1:MANY without quantifying how much that many actually is.
In mongoDB databases though it is an extremely important difference. Because it is one of the factors that we are
going to use to decide if we should de-normalize or normalize the data.

MANY TO MANY RELATIONSHIPS (MANY:MANY)
The last type of relationship is the many:many relationships
Where one movie can have many actors but at the same time one actor can play in many movies.
Here relationship basically goes in both directions where in other types it is only in one direction.

2. Referencing vs Embedding
Probably the most important aspect we need to learn about mongoDB databases
is referencing and embedding two data sets.
Each time we have two related datasets we can either represent that related data in a
reference (normalized form) or in an embedded (de-normalized form)
In the  reference form we keep the two related datasets and all the documents separated.
All the data is nicely separated which is exactly what normalized means.
We would have a one movie document and one actor document for each actor.
But if they are completely different document the movie has no way of knowing about the actors.
We use the actor IDs in order to create references on the movie document effectively connecting movies with actors.
This type of referencing is called child referencing because it is the parent, movie in this case, who references
its children, in this case the actors. There is also parent referencing and we will talk about that later.
BTW in relational databases all data is always represented in a normalized form like this.
But in a NoSQL database like mongoDB we can de-normalize the data into a de-normalized form simply by
embedding the related document right into the main document.
With this we have all the relevant data about actors right inside in one main movie document, 
without the need for separate documents, collections, and IDs.
The result of this is that our application will need to make fewer queries to the database.
Because we can get all the data about movies and actors all at the same time
which will of course improve our performance.
The downside is that we can't really query the embedded data on its own, and if that is a requirement
of the application you need to choose a normalized design.
With normalized design there is an improvement to the performance when we often need to query the related data on its own.
Because we then can just query the data that we need and not always movies and actors together.
On the other hand when we need to query actors and movies together we are going to need many queries to the database.
So first query for the movie and then a query for each actor.
When designing your database this is the kind of stuff you need to keep in mind.

3. When to Embed and When to Reference
When we have two related datasets we have to decide if we are going to embed it or if we are going to keep them separated
and reference them from one dataset to the other.
We can use this framework Jonas has created to decide
1. Relationship Types (how two datasets are related to each other)
First we look at the type of relationships that exist between datasets.
2. Data Access Patterns (How often data is read and written. Read/write ratio)
Second we try to determine the data access pattern of the dataset that we want to embed or reference
This means to analize how often data is read and written in that dataset.
3. Data Closeness (How much the data is related, how we want to query)
Data closeness is a made up term but what it means is how much the data is really related
and how we want to query the data from the database.

To take the decision we need to combine all these 3 criteria and not just use one them in isolation.
Usually when we have a 1:FEW relationship we will always embed the related dataset into the main dataset.
In a 1:MANY relationship thins are a bit fuzzy in this case we will need to decide according to the other two criteria.
On the other hand on a 1:TON or MANY:MANY relationship we usually always reference the data.
Because if we actually embed in this case we would quickly create way too large documents,
even potentially surpassing the maximum limit of 16 megabytes.
Solution is of course referencing or normalizing the data in this case.
For example in our movie database we have around 100 images associated to each movie. We could say it is a
1:MANY relationship or are we going to embed or reference? We don't know so let's take a look at the other two criteria
Second criteria is about data access patterns which is a fancy description for evaluating whether a certain dataset
is mostly read from or written to. If the dataset we are deciding is about mostly read and the data is not updated a lot
then we should probably embed that dataset. A high read/write ratio means there is a lot more reading than writing.
The reason this is a good candidate for embedding is we only need one trip to the database per query,
while referencing we need two trips. If we embed data that is read a lot in each query we save one trip to the database
making the entire process way more performant.
Out movie image example would be a good candidate for embedding. Because once the 100 images are saved to the database they are not updated anymore.
On the other hand if our data is updated a lot we should consider referencing or normalizing the data.
That is because it is more work for the database engine to update and embed a document than a more simple standalone document.
And since our main goal is performance we normalize the dataset. Let's say each movie has many reviews
and each review can be marked as helpful by the user. So each time someone clicks on the this review was helpful w need to update
the corresponding document. This means the data can change all the time so this is great candidate for normalizing.
The last criteria is the data closeness which is a measure for how much the data is related.
So if the two datasets really intrinsically belong together they should probably be embedded into one other.
In our example all users can have many email addresses on their account and
since they are so intrinsically connected to the user there is no doubt emails should be embedded into the document.
If we frequently need to query both of the datasets on their own then that it a very good reason to normalize the data
into two separate datasets, even if they are closely related. Imagine we have a quiz in our app where users
have to identify a movie based on images. This means we are going to query a lot of images on their own,
without necessarily querying for the movies themselves. So if we apply the third criteria we come to the conclusion
that we should actually normalize the image dataset. Because if we implement this quiz functionality images
are going to be queried on their own all the time.
To wrap it up we should look at all three criteria together rather than just one of the min isolation.
Because that might lead to less optimal decisions. Jonas says less optimal instead of wrong because none of the mare completely right
or completely wrong ways of modeling our data. There are no hard rules these are just guidelines.

        CRITERIA                                     EMBEDDING                                          REFERENCING 
1. RELATIONSHIP TYPE                                  1:FEW                                              1:MANY
(HOW TWO DATASETS ARE RELATED TO EACH OTHER)          1:MANY                                             1:TON
                                                                                                    MANY:MANY

2. DATA ACCESS PATTERNS                         DATA IS MOSTLY READ                                    DATA IS UPDATED A LOT
(HOW OFTEN DATA IS READ AND WRITTEN             DATA DOES NOT CHANGE QUICKLY                           LOW READ/WRITE RATIO
READ/WRITE RATIO)                               HIGH READ/WRITE RATIO

3. DATA CLOSENESS                                DATASETS REALLY BELONG TOGETHER                WE FREQUENTLY NEED TO QUERY BOTH
(HOW "MUCH" THE DATA IS RELATED,                                                                     DATASETS ON THEIR OWN
HOW WE WANT TO QUERY)



4. Types of Referencing
Let's say that we have chosen to normalize our datasets. We still have to chose between 3 different types of referencing.
1. Child referencing
2. Parent referencing 
3. Two way referencing

1. Child referencing 
Let's take a look at the error logging example from before again.
In this case we can have millions of log documents.
In child referencing we basically reference to the related child documents in a parent document.
They are usually stored in an array. Each log has an ID and in the app document there is an array
with all those IDs. However the problem is this array of IDs can become very large if there are lots of children.
And this is an anti-pattern in mongoDB. An anti-pattern is something we should avoid.
Also child referencing makes it so the parents and children are very tightly coupled, which is not always ideal.
That is exactly why we have parent referencing 

2. Parent referencing 
Parent referencing work the other way of child referencing.
In each child document we keep a reference to the parent element.
In this example the app ID is 23 so in each log there is a app field with the id of 23
so that the child always knows its parent. In this case the parent actually knows nothing of the child.
Not who they are and not how many they are. They are more isolated and standalone this can be beneficial sometimes.
Let's say there are 2 million error logs. In the case of child referencing that would mean there are 2 million ID references
in the app document. Remember that there is a 16 megabyte limit on documents. If we kept adding these child IDs to the parent
then we would hit the 16 megabyte limit pretty quickly. So this is not going to work.
With parent referencing this is not a problem. We will have two million log documents
but each of them will hold the ID of their parent. 
So child referencing is best used for 1:FEW relationships where we know before hand that the array
of documents will not grow too much.
On the other hand parent referencing is best used for 1:MANY or 1:TON relationships
Always keep in mind that one of the most important principals of mongoDB data modeling is that
an array should never be allowed to grow indefinitely, in order to keep below the 16 megabyte limit.
We also don't want to our users an array with thousands of IDs each time they request a parent dataset.

3. Two Way Referencing
This time our example is the movie and actor datasets from before.
Each movie has many actors and each actor plays in many movies.
This is a typical MANY:MANY relationship. We usually use two way referencing
to design MANY:MANY relationships. In each movie we will keep references to all the actors
that star in that movie. So a bit like child referencing. However at the same time
in each actor document we also keep references to all the movies that the actor played in.
So movies and actors are connected in both directions. This makes it really easy to search for both movies
and actors completely independently. While also making it easy to find the actors associated with
each movie and the movies associated to each actor.

SUMMARY
* The most important principle is: Structure your data to match the ways your application queries and updated data;
* In other words: Identify the questions that arise from your applications use cases first,
and then model your data so that the questions can get answered in the most efficient way;
FOr example will i need to query actors and movies always together or are there scenarios where i only
query movies or only actors.
* In general, always favour embedding, unless there is a good reason not to embed. Especially on 1:FEW and 1:MANY relationships;
* A 1:TON or MANY:MANY relationships are a good reason to reference instead of embedding;
* Favour referencing when data is updated a lot and if you need to frequently access dataset on its own;
* Use embedding whe data is mostly read but rarely updated, and whe two datasets belong intrinsically together;
* Don't allow arrays to grow indefinitely. THerefore if you need to normalize us child referencing for 1:MANY relationships,
and parent referencing for 1:TON relationships;
* Use two way referencing for MANY:MANY relationships